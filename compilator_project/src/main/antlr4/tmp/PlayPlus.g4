grammar PlayPlus;

import PlayPlusWords;

//Programme
root: map_declaration
    |iMPORT_DECLARATION
     (dECLARATION*)?
      main
    | EOF;

map_declaration: MAP COLON NUMBER NUMBER symbols;
symbols: (SYMBOLES)+;

// Import declaration
main: MAIN AS FUNCTION LPAR RPAR COLON VOID
            DO
            (iNSTRUCTION)*
            DIG LPAR RPAR SEMICOLON
            (iNSTRUCTION)*
            END;
bOOLEAN: TRUE | FALSE;
iMPORT_DECLARATION: DIES IMPORT fILE_DECLARATION ;
fILE_DECLARATION: FILENAME;

// Variable declaration
dECLARATION: vAR_DECLARATION
    | fCT_DECLARATION
    | cONST_DECLARATION
    | eNUM_DECLARATION
    | sTRUCT_DECLARATION;

fCT_DECLARATION: ID AS FUNCTION LPAR (aRG_LIST)? RPAR COLON (sCALAR|VOID) DO (iNSTRUCTION_BLOCK)+ END;
cONST_DECLARATION: CONST ID AS tYPE (AFFECT|EQUAL) iNIT_VAR SEMICOLON;
sTRUCT_DECLARATION: sTRUCTURE;
eNUM_DECLARATION: ENUM ID (AFFECT|EQUAL) LPAR ID (COMMA ID)* RPAR SEMICOLON;
vAR_DECLARATION: ID (COMMA (ID))* (SEMICOLON ID)* AS tYPE ((AFFECT|EQUAL) iNIT_VAR)? SEMICOLON;

aRG_LIST: ID (COMMA ID)* AS tYPE (COMMA ID (COMMA ID)* AS tYPE)*;
iNSTRUCTION_BLOCK: ((vAR_DECLARATION)*
    | (eNUM_DECLARATION)*
    | (cONST_DECLARATION)*
    | (sTRUCT_DECLARATION)*)? (iNSTRUCTION)+;

// Variable initialisation
iNIT_VAR: bOOLEAN | integer | CHARACTER | iNIT_ARRAY | iNT_EXPRESSION | bOOL_EXPRESSION | STRING;
iNIT_ARRAY: LPAR (iNIT_VAR (COMMA iNIT_VAR)*)? RPAR;


// EXPRESSIONS

// Integer expression
integer: ('-')? NUMBER;
iNT_EXPRESSION: (LPAR)* iEPRIM (RPAR)* (op (LPAR)* iEPRIM (RPAR)*)*
       | MINUS rIGHT_EXPRESSION;
op: MINUS | PLUS | ASTERISK | DIVIDE | MODULO;
iEPRIM: (lEFT_EXPRESSION | (integer|NUMBER) | fUNCTION_CALL)
(op (lEFT_EXPRESSION | (integer | NUMBER) | fUNCTION_CALL))*
    | (lEFT_EXPRESSION | (integer|NUMBER) | fUNCTION_CALL);


//right expression mauvais car on peut avoir un string : (3>5) or "hola"
//dans la partie semantique, on devra définir si a gauche et a droite d'un or ça doit être un même type
// Right Expression
rIGHT_EXPRESSION: bOOL_EXPRESSION
    | STRING
    | CHARACTER
    | iNT_EXPRESSION
    | lEFT_EXPRESSION
    | ID LPAR (rIGHT_EXPRESSION (COMMA rIGHT_EXPRESSION)*)? RPAR
    | LPAR rIGHT_EXPRESSION RPAR;

// Boolean expression
op_bool: OR | SMALLER | BIGGER | EQUAL | SMALLEROREQUAL | BIGGEROREQUAL | DIFFERENT | AND;
//bOOL_EXPRESSION: bOOLEAN bEPRIM
  //  | NOT rIGHT_EXPRESSION bEPRIM;
bOOL_EXPRESSION: bEPRIM ((op|op_bool) bEPRIM)*
        | NOT rIGHT_EXPRESSION;

rIGHT_EXP_BOOL: iNT_EXPRESSION | CHARACTER | STRING;
//bEPRIM: op_bool rIGHT_EXPRESSION bEPRIM;
bEPRIM: (LPAR)* iEPRIM (RPAR)* op_bool (LPAR)* iEPRIM (RPAR)* (op_bool bEPRIM)* |
(LPAR)* NOT? ((TRUE|FALSE|ID LBRACKET rIGHT_EXPRESSION (COMMA rIGHT_EXPRESSION)? RBRACKET)
    (op_bool NOT? (lEFT_EXPRESSION|TRUE|FALSE))*
    | lEFT_EXPRESSION op_bool NOT? (lEFT_EXPRESSION|TRUE|FALSE)) (RPAR)* ((op|op_bool) bOOL_EXPRESSION)*
    | (LPAR)* rIGHT_EXP_BOOL (op_bool rIGHT_EXP_BOOL)+ (RPAR)*
 ;

// Left Expression
lEFT_EXPRESSION: ID lEPRIM
    | ID LBRACKET rIGHT_EXPRESSION (COMMA rIGHT_EXPRESSION)? RBRACKET lEPRIM;
lEPRIM: DOTE ID lEPRIM
    |;

tYPE: sCALAR | aRRAY | sTRUCTURE | STR;
sCALAR: BOOL | INT | CHAR;
aRRAY: sCALAR LBRACKET (NUMBER)+ (COMMA (NUMBER)+)? RBRACKET; // Pourquoi Scalar, je ne sais pas
sTRUCTURE: ID AS RECORD (vAR_DECLARATION)+ END SEMICOLON;

iNSTRUCTION: IF LPAR rIGHT_EXPRESSION RPAR THEN (iNSTRUCTION)+ END
    | IF LPAR rIGHT_EXPRESSION RPAR THEN (iNSTRUCTION)+ ELSE (iNSTRUCTION)+ END
    | WHILE LPAR rIGHT_EXPRESSION RPAR DO (iNSTRUCTION)+ END
    | REPEAT (iNSTRUCTION)+ UNTIL LPAR rIGHT_EXPRESSION RPAR END
    | FOR ID AFFECT rIGHT_EXPRESSION TO rIGHT_EXPRESSION DO (iNSTRUCTION)+ END // J'ai aussi du mal a comprendre celui ci
    | lEFT_EXPRESSION AFFECT rIGHT_EXPRESSION SEMICOLON
    | aCTION_TYPE SEMICOLON
    | fUNCTION_CALL
    | dECLARATION;

fUNCTION_CALL: ID LPAR (rIGHT_EXPRESSION (COMMA rIGHT_EXPRESSION)*)? RPAR SEMICOLON;

aCTION_TYPE: LEFT LPAR (rIGHT_EXPRESSION)? RPAR
    | RIGHT LPAR (rIGHT_EXPRESSION)? RPAR
    | UP LPAR (rIGHT_EXPRESSION)? RPAR
    | DOWN LPAR (rIGHT_EXPRESSION)? RPAR
    | JUMP LPAR (rIGHT_EXPRESSION)? RPAR
    | FIGHT LPAR RPAR
    | DIG LPAR RPAR;
